What is Abstraction?
Abstraction means hiding complex internal details and showing only the essential features of an object.
It helps users interact with objects without knowing how they work internally.

Why Abstraction is Needed
Reduces complexity
Improves security by hiding internal details
Helps in designing clean APIs
Makes code easier to maintain
Allows focusing on what an object does, not how it does it

Abstraction in Python
Python provides abstraction using:
‚úî Abstract Classes (via abc module)
‚úî Interfaces (Python doesn't have pure interfaces, but abstract classes act like them)

Example 1: Abstract Class in Python
from abc import ABC, abstractmethod

class Animal(ABC):                      # Abstract class
    
    @abstractmethod
    def sound(self):                   # Abstract method
        pass

class Dog(Animal):
    def sound(self):
        print("Bark")

class Cat(Animal):
    def sound(self):
        print("Meow")

# a = Animal()  # ‚ùå Error: Cannot instantiate an abstract class

d = Dog()
c = Cat()

d.sound()  # Bark
c.sound()  # Meow

‚úî Key points:
Animal hides how the sound is produced.
Only promises what every animal must implement.
Each animal implements sound differently.


Example 2: Abstraction with Real Logic Hidden
from abc import ABC, abstractmethod

class Payment(ABC):
    
    @abstractmethod
    def pay(self, amount):
        pass

class UPI(Payment):
    def pay(self, amount):
        print(f"UPI payment of ‚Çπ{amount} successful")

class CreditCard(Payment):
    def pay(self, amount):
        print(f"Credit Card payment of ‚Çπ{amount} successful")

# User only sees:
payment = UPI()
payment.pay(500)

payment = CreditCard()
payment.pay(500)

üëâ The user doesn‚Äôt need to know
encryption
OTP validation
bank APIs
transaction hashing
Those details are hidden.


Example 3: Abstraction Using Functions
class Car:
    def start(self):                                          //User doesn‚Äôt need to know internal steps.
        self._fuel_check()
        self._engine_ignite()
        self._oil_flow()
        print("Car started")

    def _fuel_check(self):
        pass

    def _engine_ignite(self):
        pass

    def _oil_flow(self):
        pass

car = Car()
car.start()   # User sees only one simple method.


Real-Life Applications of Abstraction
1Ô∏è‚É£ Mobile Phone
You click Camera ‚Üí Click Button
But inside the phone:
autofocus
exposure calculation
lens movement
image processing
storing image
All these complex steps are hidden.
You only see a simple interface.

2Ô∏è‚É£ ATM Machine
User presses:
üëâ Withdraw ‚Çπ1000
Internally ATM does:
Card authentication
Balance check
Network communication
Money dispensing mechanism
Transaction logging
Everything is hidden except the simple UI.

3Ô∏è‚É£ Car Driving
You press accelerator ‚Üí car moves forward.
But hidden inside:
fuel injection
combustion
pistons
transmission
sensors
ECU microcontroller
Driver does not see the internal engine logic.

4Ô∏è‚É£ Online Payment Systems
Users only see:
üëâ Pay Now Button
Hidden operations:
token generation
encryption
payment gateway API
settlement
fraud check
OTP validation
bank server communication
All complexity is abstracted.

5Ô∏è‚É£ Database Operations (SQL ORM)
                                     User.objects.filter(age > 20)
You don‚Äôt need to write raw SQL.
ORM hides:
query generation
query optimization
connection pooling
execution steps

6Ô∏è‚É£ Machine Learning Libraries
You call:                            model.fit(x, y)
But internally:
gradient computation
backpropagation
weight updates
optimization algorithms
All hidden inside the library.

‚≠ê Difference Between Abstraction and Encapsulation
Abstraction	Encapsulation
Hides implementation details	Hides data inside a class
Shown through abstract classes, interfaces	Done using private/protected variables
Focus on what a system does	Focus on how it is protected

‚≠ê Abstraction vs Interface ‚Äî Conceptual Difference
Abstraction :
Hides internal implementation details.
Focuses on what the object does.
Can provide partial implementation.

Interface :
Defines a strict contract of what methods a class must implement.
Focuses on how the object should behave.
Provides no implementation (in strict interface systems like Java).

‚≠ê 1. Abstraction (Abstract Class)
‚úî Features:
Can have abstract + concrete methods
Can have variables, constructors, etc.
Child classes may partially inherit implementation
Supports partial abstraction
                                                                  from abc import ABC, abstractmethod
                                                                  
                                                                  class Animal(ABC):
                                                                      @abstractmethod
                                                                      def sound(self):
                                                                          pass
                                                                  
                                                                      def sleep(self):
                                                                          print("Sleeping...")   # concrete method

‚≠ê 2. Interface (Pure Contract)
Python doesn‚Äôt have pure ‚Äúinterfaces‚Äù like Java,
but abstract classes can behave like interfaces if we make only abstract methods.
                                                                  from abc import ABC, abstractmethod
                                                                  
                                                                  class Payment(ABC):
                                                                      @abstractmethod
                                                                      def pay(self, amount):
                                                                          pass
                                                                  
                                                                      @abstractmethod
                                                                      def refund(self, amount):
                                                                          pass

‚úî No implementation ‚Üí behaves like an interface.
‚úî Any class implementing this must define both methods.
