‚≠ê What is a Constructor?
A constructor is a special method inside a class that is automatically called when an object is created.
It is used to:
Initialize object variables
Set default values
Allocate resources
Ensure the object starts in a valid state

‚≠ê Why Do We Need Constructors?
‚úî Automatically run when object is created
‚úî Avoids manually setting attributes every time
‚úî Helps initialize data cleanly
‚úî Makes code more readable and error-free

                                              class Student:
                                                  def __init__(self, name, roll):
                                                      self.name = name
                                                      self.roll = roll
                                              
                                              s = Student("John", 10)
                                              print(s.name, s.roll)

1Ô∏è‚É£ name and roll are just temporary variables. b They exist only inside the constructor. Once the constructor finishes, these variables disappear. So we must store them (using self.name,self.roll) inside the object. 


‚úÖ Does a class take arguments?
p = Player(health=80, level=3)
It looks like the class Player is taking arguments‚Ä¶‚Ä¶but actually:
‚úîÔ∏è The class itself does NOT take arguments.
‚úîÔ∏è The arguments are passed to the constructor method __init__() inside the class.
Python does two things:
1Ô∏è‚É£ Creates an empty object of class Player (behind the scenes using __new__())
2Ô∏è‚É£ Calls the constructor __init__(self, 80, 3) and assigns the values to the object.


What does object c contain?   c = Car("BMW", 120)
Attributes:  c.brand ‚Üí "BMW"    c.speed ‚Üí 120
Methods:  c.accelerate()


‚úÖ Scope of self.name and self.roll_no
‚úîÔ∏è These variables belong to the object (instance) of the class.
‚úîÔ∏è Their scope is anywhere inside the class, in any method, as long as you access them through self.
because self refers to the current object, and the variables attached to self become object-level variables.

Accessed using:
self.variable (inside class)
object.variable (outside class)
2Ô∏è‚É£ Local Variables
Definition: Variables created inside a method that belong only to that method.
Where stored? --------------> Only inside the method‚Äôs temporary memory. Lifetime: Destroyed once the method finishes executing.
...........................................................................................................................................
-------------------------------------------------------------------------------------------------------------------------------------------------------

Minimizing if‚Äìelse using OOP is one of the biggest advantages of object-oriented programming. The object decides behavior, not a condition.
This is done by applying OOP concepts like:
‚úÖ Polymorphism
‚úÖ Inheritance
‚úÖ Strategy Pattern (Behavior Injection)
‚úÖ Factory Pattern
‚ùå Avoiding ‚Äútype checking‚Äù (if type == ...)

Below are clear explanations + before/after code so you see EXACTLY how if-else gets minimized.
Using polymorphism :
if-else:                    def make_sound(animal):
                            if animal == "dog":
                                print("Bark")
                            elif animal == "cat":
                                print("Meow")
                            elif animal == "cow":
                                print("Moo")
                            else:
                                print("Unknown")

Polymorphism:                                                     class Animal:
                                                                      def sound(self):
                                                                          pass
                                                                  
                                                                  class Dog(Animal):
                                                                      def sound(self):
                                                                          print("Bark")
                                                                  
                                                                  class Cat(Animal):
                                                                      def sound(self):
                                                                          print("Meow")
                                                                  
                                                                  class Cow(Animal):
                                                                      def sound(self):
                                                                          print("Moo")

‚≠ê 2. Using Strategy Pattern (Inject behavior dynamically)
def pay(amount, payment_type):
    if payment_type == "upi":
        print("Paying with UPI")
    elif payment_type == "card":
        print("Paying with Card")
    elif payment_type == "netbanking":
        print("Paying with NetBanking")
                                                                class PaymentStrategy:
                                                                    def pay(self, amount):
                                                                        pass
                                                                
                                                                class UPI(PaymentStrategy):
                                                                    def pay(self, amount):
                                                                        print("Paying", amount, "via UPI")
                                                                
                                                                class Card(PaymentStrategy):
                                                                    def pay(self, amount):
                                                                        print("Paying", amount, "via Card")
                                                                
                                                                class NetBanking(PaymentStrategy):
                                                                    def pay(self, amount):
                                                                        print("Paying", amount, "via NetBanking")

‚≠ê 3. Using Factory Pattern (instead of if-else to create objects)
if shape_type == "circle":
    return Circle()
elif shape_type == "square":
    return Square()
                                                                
                                                                class ShapeFactory:
                                                                    registry = {}
                                                                
                                                                    @classmethod
                                                                    def register(cls, name, shape_class):
                                                                        cls.registry[name] = shape_class
                                                                
                                                                    @classmethod
                                                                    def create(cls, name):
                                                                        return cls.registry[name]()


‚≠ê 4. Using Dictionary Dispatching (Pythonic OOP-style)
if cmd == "start":
    start()
elif cmd == "stop":
    stop()
elif cmd == "pause":
    pause()
                                                                actions = {
                                                                    "start": start,
                                                                    "stop": stop,
                                                                    "pause": pause
                                                                }
                                                                
                                                                actions[cmd]()     # calls correct function

‚≠ê When to use what?
[Situation_______________]                                  [Best OOP Solution__________________]
Many types performing different behavior	                         Polymorphism
Many algorithms or strategies	S                                    trategy Pattern
Choosing between object types	                                     Factory Pattern
Menu or command mapping	                                           Dictionary Dispatching












‚úÖ What is a Destructor?
A destructor is a special method that is executed automatically when an object is destroyed (i.e., when it is garbage-collected).
In Python, the destructor is written using:
                                                            def __del__(self):
                                                                # cleanup code
Why would you use destructors?
Destructors help when your object uses external resources that must be cleaned manually, such as:
‚úîÔ∏è Files
‚úîÔ∏è Network connections
‚úîÔ∏è Database connections
‚úîÔ∏è Memory allocated outside Python
‚úîÔ∏è Temporary data or logs
Python has automatic garbage collection, so destructors are not often needed, but still useful in some cases.

üïò When is __del__() called?
When an object goes out of scope and has no references left
When the program ends
When the garbage collector deletes the object
Python does NOT guarantee the exact time when __del__ will run. So you should not rely on it for important logic (like saving user data).


-------------------------------------------------------------------------------------------------------------------------------
class Member:
    def __init__(self ,name, age, phone, address, salary):
        self.name = name
        self.age= age
        self.phone = phone
        self.address = address
        self.salary = salary

    def printSalary(self):
        print(self.salary)

class Employee(Member):
    def __init__(self, name, age, phone, address, salary, specialization):
        super().__init__(name, age, phone, address, salary)
        self.specialization = specialization

/*‚ùì Why does Employee take arguments like name, age, phone, address, salary?
Because an Employee IS-A Member (inheritance). That means an employee also has: name,age,phone,address,salary
Those things are required by the parent class constructor, so the child must pass them upward.
‚ú® Additional property only for Employees: specialization
So Employee has all member attributes + specialization.     */

/* üéØ 4. What is super().__init__(...) ?
super() is used to call the parent class constructor or methods. "Call the Member class constructor, and initialize the common attributes."
Without super(), you would need to rewrite: 
self.name = name
self.age = age
self.phone = phone
self.address = address
self.salary = salary */

‚úÖ Case 1 ‚Äî Parent has __init__() but Child does NOT call it
                                                          class Parent:
                                                              def __init__(self, x):
                                                                  self.x = x
                                                          
                                                          class Child(Parent):
                                                              def __init__(self):
                                                                  self.y = 100   # Not calling Parent.__init__()
‚úîÔ∏è Why?
Because we created our own constructor in Child, the parent‚Äôs constructor is not automatically called. Child has its own __init__ ‚Üí this overrides the parent constructor.
Python does NOT call the parent __init__ for you. So self.x is never created ‚Üí accessing it gives an error.

‚úÖ Case 2 ‚Äî Child has no constructor ‚Üí Parent‚Äôs constructor runs automatically
                                                          class Parent:
                                                              def __init__(self, x):
                                                                  self.x = x
                                                          
                                                          class Child(Parent):
                                                              pass
                                                          
                                                          c = Child(10)
                                                          print(c.x)   # Works!
‚úîÔ∏è Why?
Because child does NOT define __init__, so Python uses the parent‚Äôs constructor.

‚úÖ Case 3 ‚Äî Child has its own constructor but does not call parent AND parent needs arguments
                                                          class Parent:
                                                              def __init__(self, x):
                                                                  self.x = x
                                                          
                                                          class Child(Parent):
                                                              def __init__(self, y):
                                                                  self.y = y
                                                          
                                                          c = Child(50)
This works, but:        print(c.x)   ‚ùå Error:  AttributeError: 'Child' object has no attribute 'x' . ‚úîÔ∏è Because parent __init__ never executed.

Why doesn‚Äôt Python automatically call parent __init__()?
Because child class may want custom initialization, and Python gives full control to the child class.
Otherwise, many advanced OOP patterns wouldn‚Äôt work.
So Python only runs the parent __init__() if the child does not have one.






