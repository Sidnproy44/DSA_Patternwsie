Below is a complete, structured, exam-ready + industry-ready guide to all major sorting algorithms, their intuition, time complexities, and real-world applications.
To make it easy, I grouped them into:
Simple comparison sorts
Efficient comparison sorts
Non-comparison (linear-time) sorts
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Specialized modern sorting algorithms used in real systems
ðŸ”µ 1. SIMPLE COMPARISON SORTS

1ï¸âƒ£ Bubble Sort
Idea: Repeatedly swap adjacent elements if they are in the wrong order. Largest elements "bubble" to the top.
Time Complexity:
Average/Worst: O(nÂ²)
Best: O(n) (if array nearly sorted)
Space: O(1)
Real-world Applications:
Used in teaching beginners (very easy to understand).
Detecting almost-sorted data quickly (if early termination is used).
Small datasets in embedded systems.

2ï¸âƒ£ Selection Sort
Idea: Find the minimum element and place it at the beginning.
Time Complexity:
All cases: O(nÂ²)
Space: O(1)
Real-world Applications:
Very useful when swaps are costly (e.g., flash memory writes).
Good for sorting very small arrays.
Used sometimes in hardware implementations.

3ï¸âƒ£ Insertion Sort
Idea: Build a sorted array one element at a time by inserting items into their correct position.
Time Complexity:
Average/Worst: O(nÂ²)
Best: O(n) (nearly sorted)
Space: O(1)
Real-world Applications:
Used in online algorithms where data arrives one by one.
Sorting small chunks in Timsort and QuickSort.
Good for nearly sorted input (e.g., event logs).
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ”µ 2. EFFICIENT COMPARISON SORTS
4ï¸âƒ£ Merge Sort
Idea: Divide array into halves â†’ sort each half â†’ merge.
Time Complexity:
All cases: O(n log n)
Space: O(n)
Real-world Applications:
Sorting linked lists (O(1) extra space).
Used in external sorting (huge files that don't fit in RAM).
Used in many standard libraries:
Java (for objects)
Pythonâ€™s Timsort (as a component)

5ï¸âƒ£ Quick Sort
Idea: Choose pivot â†’ partition array into smaller and larger elements â†’ recursively sort.
Time Complexity:
Average: O(n log n)
Worst: O(nÂ²) (rare if pivot chosen well)
Space: O(log n)
Real-world Applications:
Used in C, C++, Go, and many language libraries.
Excellent for in-memory sorting.
When random access is fast (arrays).
Fastest practical comparison sort in many cases.

6ï¸âƒ£ Heap Sort
Idea: Build a max-heap â†’ repeatedly remove max.
Time Complexity:
All cases: O(n log n)
Space: O(1)
Real-world Applications:
When memory is very limited.
Used in priority queues, scheduling jobs.
Great for streaming data where you need the largest k values.

7ï¸âƒ£ Shell Sort
Idea: Generalized insertion sort using gaps.
Time Complexity:
Depends on gap sequence
Around O(n^(3/2))
Real-world Applications:
Work efficiently on medium-sized arrays.
Used where memory is extremely limited (O(1)).
Sorting data that is already partially sorted.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

ðŸ”µ 3. NON-COMPARISON (LINEAR-TIME) SORTS
These outperform comparison sorts when conditions allow.

8ï¸âƒ£ Counting Sort
Idea: Count frequency of each value, then compute positions.
Time Complexity:
O(n + k) where k = max value
Space: O(k)
Real-world Applications:
Sorting integers within a small range.
Used inside Radix Sort.
Used in histogram-based algorithms in imaging.

9ï¸âƒ£ Radix Sort
Idea: Sort numbers digit by digit (using Counting Sort).
Time Complexity:
O(d Ã— (n + k))
d = number of digits
Space: O(n + k)
Real-world Applications:
Sorting huge lists of integers faster than comparison sorts.
Used by databases and search engines.
Fast for IP addresses, phone numbers, floating point numbers.

ðŸ”Ÿ Bucket Sort
Idea: Distribute elements into buckets, sort each bucket, merge.
Time Complexity:
Best: O(n)
Worst: O(nÂ²) (when everything goes into one bucket)
Space: O(n)
Real-world Applications:
Sorting uniformly distributed data.
Machine learning: KNN nearest neighbors (bucket neighborhoods).
Computer graphics for color histograms.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ðŸ”µ 4. MODERN REAL-WORLD SORTING ALGORITHMS (INDUSTRY LEVEL)

1ï¸âƒ£1ï¸âƒ£ Timsort
Used In: Python, Java, Android
Idea: Hybrid of Merge Sort + Insertion Sort. Detects â€œrunsâ€ (already sorted segments).
Time Complexity:
Best: O(n)
Worst: O(n log n)
Applications:
Ideal for real-world data which is usually partially sorted.
High-performance sorting in Python lists and Java Arrays.sort().

1ï¸âƒ£2ï¸âƒ£ IntroSort
Used In: C++, Rust, .NET STL
Idea: Starts as QuickSort â†’ switches to HeapSort on bad cases.
Time Complexity:
Worst-case Guaranteed O(n log n)
Applications:
Standard sorting in C++ (std::sort).
Used when performance + worst-case guarantee are required.

1ï¸âƒ£3ï¸âƒ£ External Merge Sort (for huge data)
Idea: Divide massive files into chunks â†’ sort â†’ merge on disk.
Applications:
Database engines
Sorting logs of size GB / TB
Hadoopâ€™s distributed sort (HDFS)

1ï¸âƒ£4ï¸âƒ£ Parallel Sorting Algorithms
Examples: Parallel QuickSort, Bitonic Sort, Odd-Even Sort
Applications:
GPU sorting
Real-time analytics
High-frequency trading
Distributed systems

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
...............................................................................................................................................................................

Simple sorts

Bubble Sort (stable, O(nÂ²))
def bubble_sort(a):
    """In-place bubble sort. Returns the list for convenience."""
    n = len(a)
    a = list(a)
    for i in range(n):
        swapped = False
        for j in range(0, n - 1 - i):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                swapped = True
        if not swapped:  # already sorted
            break
    return a

# Usage
print(bubble_sort([3,1,4,1,5,9,2]))

----------------------------------------------------------------------------------------------------------------------------------------------------------
Selection Sort (in-place, O(nÂ²), not stable)
def selection_sort(a):
    a = list(a)
    n = len(a)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if a[j] < a[min_idx]:
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]
    return a
---------------------------------------------------------------------------------------------------------------------------------------------------------
Insertion Sort (stable, O(nÂ²) but O(n) for nearly-sorted)
def insertion_sort(a):
    a = list(a)
    for i in range(1, len(a)):
        key = a[i]
        j = i - 1
        while j >= 0 and a[j] > key:
            a[j+1] = a[j]
            j -= 1
        a[j+1] = key
    return a

print(insertion_sort([3,1,4,1,5,9,2]))
-------------------------------------------------------------------------------------------------------------------------------------------------------
.........................................................................................................................................................

Efficient comparison sorts
Merge Sort (stable, O(n log n), needs O(n) extra)
def merge_sort(a):
    if len(a) <= 1:
        return list(a)
    mid = len(a) // 2
    left = merge_sort(a[:mid])
    right = merge_sort(a[mid:])
    i = j = 0
    out = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            out.append(left[i]); i += 1
        else:
            out.append(right[j]); j += 1
    out.extend(left[i:]); out.extend(right[j:])
    return out

print(merge_sort([3,1,4,1,5,9,2]))
------------------------------------------------------------------------------------------------------------------------------------------------------------

Quick Sort (in-place variant, average O(n log n))
import random
def quick_sort(a):
    a = list(a)
    def _qs(l, r):
        if l >= r: return
        pivot_index = random.randint(l, r)
        pivot = a[pivot_index]
        # 3-way partition
        i, lt, gt = l, l, r
        while i <= gt:
            if a[i] < pivot:
                a[lt], a[i] = a[i], a[lt]; lt += 1; i += 1
            elif a[i] > pivot:
                a[i], a[gt] = a[gt], a[i]; gt -= 1
            else:
                i += 1
        _qs(l, lt-1); _qs(gt+1, r)
    _qs(0, len(a)-1)
    return a

print(quick_sort([3,1,4,1,5,9,2]))
------------------------------------------------------------------------------------------------------------------------------------------------------------

Heap Sort (O(n log n), in-place, not stable)
def heap_sort(a):
    a = list(a)
    import heapq
    heapq.heapify(a)
    return [heapq.heappop(a) for _ in range(len(a))]

print(heap_sort([3,1,4,1,5,9,2]))
(Note: above uses Python heap which is a min-heap and returns a new sorted list. An in-place heapify + sift-down version can be implemented if you need strictly in-place with O(1) extra.)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Shell Sort (in-place, depends on gap sequence)
def shell_sort(a):
    a = list(a)
    n = len(a)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = a[i]
            j = i
            while j >= gap and a[j-gap] > temp:
                a[j] = a[j-gap]
                j -= gap
            a[j] = temp
        gap //= 2
    return a
print(shell_sort([3,1,4,1,5,9,2]))
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
.................................................................................................................................................................................

Non-comparison / linear-time sorts (when keys are integers or limited range)

Counting Sort (O(n + k)), stable
def counting_sort(a, minimum=None, maximum=None):
    if not a:
        return []
    if minimum is None: minimum = min(a)
    if maximum is None: maximum = max(a)
    k = maximum - minimum + 1
    count = [0] * k
    for x in a:
        count[x - minimum] += 1
    # prefix sums
    for i in range(1, k):
        count[i] += count[i-1]
    out = [0] * len(a)
    # stable: iterate reversed
    for x in reversed(a):
        idx = x - minimum
        count[idx] -= 1
        out[count[idx]] = x
    return out

print(counting_sort([3,1,4,1,5,9,2]))
----------------------------------------------------------------------------------------------------------------------------------------------------------------

Radix Sort (LSD for non-negative integers)
def radix_sort(a, base=10):
    if not a:
        return []
    a = list(a)
    # handle negatives by offsetting (simplest approach)
    neg = [x for x in a if x < 0]
    pos = [x for x in a if x >= 0]
    def _radix(nums):
        if not nums: return []
        max_val = max(nums)
        exp = 1
        out = nums[:]
        while exp <= max_val:
            buckets = [[] for _ in range(base)]
            for num in out:
                digit = (num // exp) % base
                buckets[digit].append(num)
            out = [x for b in buckets for x in b]
            exp *= base
        return out
    pos_sorted = _radix(pos)
    neg_sorted = _radix([-x for x in neg])
    neg_sorted = [-x for x in reversed(neg_sorted)]
    return neg_sorted + pos_sorted

print(radix_sort([170, 45, 75, 90, 802, 24, 2, 66]))
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Bucket Sort (good for uniform distribution)
def bucket_sort(a, bucket_count=10):
    if not a:
        return []
    a = list(a)
    minimum, maximum = min(a), max(a)
    if minimum == maximum:
        return a[:]
    # create buckets
    buckets = [[] for _ in range(bucket_count)]
    for x in a:
        idx = int((x - minimum) / (maximum - minimum + 1e-9) * (bucket_count - 1))
        buckets[idx].append(x)
    # sort each bucket (use built-in which is typically Timsort)
    out = []
    for b in buckets:
        out.extend(sorted(b))
    return out

print(bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68], bucket_count=5))
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
........................................................................................................................................................................

Practical / Production

Timsort (Python built-in) â€” use this in practice
# built-in sorted uses Timsort (stable, adaptive)
data = [3,1,4,1,5,9,2]
print(sorted(data))        # returns new list
data.sort()                # in-place
-----------------------------------------------------------------------------------------------------------------------------------------------
External Merge Sort (outline for huge files)
# Pseudocode-style helper outline (not runnable as-is):
# 1. Read the input file in chunks that fit into RAM.
# 2. Sort each chunk (use .sort()) and write sorted chunk to disk as a temporary file.
# 3. Merge all sorted temporary files using a k-way merge (use heapq.merge).
#
# In Python you can use heapq.merge which lazily merges sorted inputs.
#
# Example:
#   import heapq
#   merged_iterator = heapq.merge(sorted_chunk1_iter, sorted_chunk2_iter, ...)
#   write merged_iterator to output file in streaming fashion

Utilities: verify correctness and small benchmark
ALGS = [
    bubble_sort, selection_sort, insertion_sort, merge_sort,
    quick_sort, heap_sort, shell_sort, counting_sort, radix_sort, bucket_sort
]

def is_sorted(a):
    return all(a[i] <= a[i+1] for i in range(len(a)-1))

sample = [3,1,4,1,5,9,2]
for fn in ALGS:
    try:
        out = fn(sample)
        print(f"{fn.__name__}: ok={is_sorted(out)} result={out}")
    except Exception as e:
        print(f"{fn.__name__}: error {e}")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Short complexity cheat-sheet (Python summary)

Simple sorts: Bubble/Selection/Insertion â€” O(nÂ²) (good for tiny or almost-sorted arrays)

Merge/Quick/Heap â€” O(n log n) average (Merge is stable; Quick is fastest in practice with good pivot; IntroSort used by C++ to get worst-case guarantees)

Counting/Radix/Bucket â€” O(n + k) or O(d(n + k)) â€” linear when keys/range/digits small

Use sorted() (Timsort) in Python for most real workloads
